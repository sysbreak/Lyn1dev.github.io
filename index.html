<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>lynzl@spellbound:~</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        @font-face {
            font-family: 'TerminusWeb';
            src: url('Terminus.ttf') format('truetype');
            font-display: swap;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Color scheme */
        :root {
            --lavender: #7afdf2;
            --lilac: #b4befe;
            --mint: #d4a1e3;
            --pink: #c2f5ed;
            --blue: #89b4fa;
            --yellow: #c2f896;
            --white: #cdd6f4;
            --gray: #a1a6b9;
        }

        body {
            background: #1a1a1a;
            color: var(--white);
            font-size: 16px;
            line-height: 1.0;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            -webkit-font-smoothing: none;
            -moz-osx-font-smoothing: grayscale;
            font-smooth: never;
            image-rendering: pixelated;
        }

        #terminal {
            white-space: pre-wrap;
            height: calc(100vh - 40px);
            overflow-y: auto;
            padding-bottom: 2em;
            cursor: text;
            font-size: 16px;
            line-height: 1.2;
            -webkit-font-smoothing: none;
            -moz-osx-font-smoothing: grayscale;
            font-smooth: never;
            image-rendering: pixelated;
            color: var(--white);
        }

        .input-line {
            display: flex;
            align-items: center;
            margin-top: 0.5em;
        }

        .prompt {
            color: var(--lavender);
            user-select: none;
            margin-right: 0.5em;
        }

        .static-cmd {
            color: var(--mint);
        }

        .output {
            margin-bottom: 4px;
            white-space: pre-wrap;
            color: var(--white);
        }

        .command-history {
            color: var(--gray);
        }

        .error {
            color: #f38ba8;
        }

        pre.help {
            color: var(--white);
            margin: 0.5em 0 0.5em 0;
            font-family: 'TerminusWeb', monospace;
            font-size: 16px;
            line-height: 1.0;
            letter-spacing: 0;
            background: none;
            border: none;
            padding: 0;
            box-shadow: none;
            image-rendering: pixelated;
        }

        #terminal::-webkit-scrollbar {
            width: 0;
            background: transparent;
        }

        #command-input, .command-input {
            background: none;
            border: none;
            color: var(--white);
            font-size: 16px;
            outline: none;
            caret-color: var(--lavender);
            width: 100%;
            box-shadow: none;
            padding: 0;
            margin: 0;
        }

        body, #terminal, #command-input, .command-input {
            font-family: 'TerminusWeb', monospace;
            font-size: 16px;
            line-height: 1.0;
            -webkit-font-smoothing: none;
            -moz-osx-font-smoothing: grayscale;
            font-smooth: never;
            image-rendering: pixelated;
            letter-spacing: 0;
        }
    </style>
</head>
<body>
    <div id="terminal">
        <div class="output">Type 'help' to list available commands.</div>
    </div>

    <script>
        class Terminal {
            constructor() {
                this.terminal = document.getElementById('terminal');
                this.commandHistory = [];
                this.historyIndex = -1;
                this.currentInput = '';
                this.tabCompletionCandidates = [];
                this.tabCompletionIndex = 0;
                this.isWaitingForSshConfirmation = false; // State for SSH confirmation
                this.sshTargetHost = null; // Store target host during confirmation

                // Game state for Guess the Number
                this.isGuessGameActive = false;
                this.guessGameSecretNumber = 0;
                this.guessGameAttemptsLeft = 0;
                this.guessGameMin = 1;
                this.guessGameMax = 100;
                this.guessGameTotalAttempts = 10;


                this.addNewInputLine();
                this.scrollToBottom();
            }

            setupEventListeners() {
                this.terminal.addEventListener('click', (e) => {
                    if (e.target === this.terminal || e.target.classList.contains('output') || e.target.classList.contains('command-history')) {
                        this.input.focus();
                    }
                });
                this.input.addEventListener('keydown', (e) => this.handleKeyDown(e));
            }

            handleKeyDown(e) {
                switch(e.key) {
                    case 'Enter':
                        e.preventDefault();
                        this.processCommand(this.input.value.trim());
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        this.navigateHistory('up');
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        this.navigateHistory('down');
                        break;
                    case 'Tab':
                        e.preventDefault();
                        this.handleTabCompletion();
                        break;
                }
            }

            navigateHistory(direction) {
                if (direction === 'up') {
                    if (this.historyIndex < this.commandHistory.length - 1) {
                        if (this.historyIndex === -1) {
                            this.currentInput = this.input.value;
                        }
                        this.historyIndex++;
                        this.input.value = this.commandHistory[this.commandHistory.length - 1 - this.historyIndex];
                    }
                } else {
                    if (this.historyIndex > -1) {
                        this.historyIndex--;
                        if (this.historyIndex === -1) {
                            this.input.value = this.currentInput;
                        } else {
                            this.input.value = this.commandHistory[this.commandHistory.length - 1 - this.historyIndex];
                        }
                    }
                }
            }

            handleTabCompletion() {
                const currentInput = this.input.value.trim();
                if (!currentInput) return;
                if (this.tabCompletionCandidates.length === 0) {
                    this.tabCompletionCandidates = Object.keys(commands).filter(cmd => cmd.startsWith(currentInput));
                    this.tabCompletionIndex = 0;
                }
                if (this.tabCompletionCandidates.length > 0) {
                    this.input.value = this.tabCompletionCandidates[this.tabCompletionIndex];
                    this.tabCompletionIndex = (this.tabCompletionIndex + 1) % this.tabCompletionCandidates.length;
                }
            }

            scrollToBottom() {
                this.terminal.scrollTop = this.terminal.scrollHeight;
            }

            createPrompt(cmd) {
                const prompt = document.createElement('span');
                prompt.className = 'prompt';
                // Modify prompt if game is active (optional, for now using default)
                // if (this.isGuessGameActive) {
                //     prompt.textContent = `Guess (${this.guessGameAttemptsLeft}): `;
                // } else {
                prompt.textContent = 'lynzl@spellbound:~#';
                // }
                const cmdSpan = document.createElement('span');
                cmdSpan.className = 'static-cmd';
                cmdSpan.textContent = ' ' + cmd;
                const line = document.createElement('div');
                line.className = 'input-line';
                line.appendChild(prompt);
                line.appendChild(cmdSpan);
                return line;
            }

            createOutput(content, isError = false, isHelp = false) {
                if (isHelp) {
                    const pre = document.createElement('pre');
                    pre.className = 'help';
                    pre.textContent = content;
                    return pre;
                }
                const output = document.createElement('div');
                output.className = `output${isError ? ' error' : ''}`;
                output.textContent = content;
                return output;
            }

            clearVisibleScreen() {
                while (this.terminal.firstChild) {
                    this.terminal.removeChild(this.terminal.firstChild);
                }
                this.addNewInputLine();
            }

            addNewInputLine() {
                const existingInputs = this.terminal.querySelectorAll('.input-line');
                existingInputs.forEach(line => {
                    if (line.querySelector('input')) {
                        this.terminal.removeChild(line);
                    }
                });
                const inputLine = document.createElement('div');
                inputLine.className = 'input-line';
                // let promptText = 'lynzl@spellbound:~#';
                // if (this.isGuessGameActive) { // Example for custom prompt
                //    promptText = `Guess (${this.guessGameAttemptsLeft}):`;
                // }
                inputLine.innerHTML = `
                    <span class="prompt">lynzl@spellbound:~#</span>
                    <input type="text" class="command-input" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
                `;
                this.terminal.appendChild(inputLine);
                this.input = inputLine.querySelector('.command-input');
                this.input.focus();
                this.setupEventListeners();
            }

            processCommand(cmd) {
                // Handle SSH confirmation input first
                if (this.isWaitingForSshConfirmation) {
                    const confirmationResponse = cmd.toLowerCase();
                    const targetHost = this.sshTargetHost;

                    const prevInputLine = this.input.parentElement;
                    const staticLine = this.createPrompt(cmd);
                    this.terminal.replaceChild(staticLine, prevInputLine);

                    this.isWaitingForSshConfirmation = false;
                    this.sshTargetHost = null;

                    if (confirmationResponse === 'yes' || confirmationResponse === 'y') {
                        const outputMessage = `Connecting to ${targetHost}...`;
                        const output = this.createOutput(outputMessage);
                        this.terminal.appendChild(output);
                        this.scrollToBottom(); 

                        setTimeout(() => {
                            window.location.href = 'https://madeline.spellbound.sh';
                        }, 2000);
                        // No new input line if redirecting
                    } else {
                        const outputMessage = "Connection cancelled.";
                        const output = this.createOutput(outputMessage);
                        this.terminal.appendChild(output);
                        this.addNewInputLine(); 
                        this.scrollToBottom();
                    }
                    return; 
                }
                
                // Make current input static (standard behavior)
                const prevInputLine = this.input.parentElement;
                const staticLine = this.createPrompt(cmd);
                this.terminal.replaceChild(staticLine, prevInputLine);

                // Handle Guess the Number game input
                if (this.isGuessGameActive) {
                    this.handleGuess(cmd);
                    this.addNewInputLine();
                    this.scrollToBottom();
                    return;
                }

                // Normal command processing
                if (!cmd && !this.isGuessGameActive) { // No command and not in game
                    this.addNewInputLine();
                    return;
                }

                if (cmd) { // Only add to history if it's a non-empty command
                    this.commandHistory.push(cmd);
                }
                this.historyIndex = -1;
                this.currentInput = '';
                this.tabCompletionCandidates = [];
                this.tabCompletionIndex = 0;
                
                const commandParts = cmd.split(' ');
                const baseCmd = commandParts[0];
                const argument = commandParts.slice(1).join(' ');

                if (commands[baseCmd]) {
                    const result = commands[baseCmd].execute(argument); // 'this' inside execute is 'commands[baseCmd]'
                    if (result && typeof result.then === 'function') { // Async command
                        result.then(outputContent => {
                            if (outputContent !== undefined) { // Only append if there's content
                                const output = this.createOutput(outputContent);
                                this.terminal.appendChild(output);
                            }
                            // Check if game was started and needs no further input line from here
                            if (baseCmd === 'guess' && this.isGuessGameActive) {
                                // The game will prompt itself if needed via its own output
                            } else {
                                this.addNewInputLine();
                            }
                            this.scrollToBottom();
                        }).catch(error => {
                            const errorOutput = this.createOutput(`Error: ${error}`, true);
                            this.terminal.appendChild(errorOutput);
                            this.addNewInputLine();
                            this.scrollToBottom();
                        });
                    } else if (result !== undefined) { // Sync command with output
                        if (baseCmd === 'help') {
                            const output = this.createOutput(result, false, true);
                            this.terminal.appendChild(output);
                        } else if (baseCmd === 'fetch') {
                            const output = document.createElement('div');
                            output.className = 'output';
                            output.innerHTML = result; // Assumes fetch returns HTML string
                            this.terminal.appendChild(output);
                        } else if (baseCmd === 'guess' && this.isGuessGameActive) {
                            // Game start message is handled, specific game prompts are in handleGuess
                             const output = this.createOutput(result);
                             this.terminal.appendChild(output);
                        }
                         else {
                            const output = this.createOutput(result);
                            this.terminal.appendChild(output);
                        }
                        // If it's the start of the guess game, the message is already the prompt.
                        // Otherwise, add a new input line.
                        if (!(baseCmd === 'guess' && this.isGuessGameActive)) {
                           this.addNewInputLine();
                        }
                        this.scrollToBottom();
                    } else { // Command that produces no direct output but might modify state (like 'clear', or 'guess' start)
                        if (!(baseCmd === 'guess' && this.isGuessGameActive)) {
                           this.addNewInputLine();
                        }
                        this.scrollToBottom();
                    }
                } else {
                    const error = this.createOutput(`-bash: ${cmd}: command not found`, true);
                    this.terminal.appendChild(error);
                    this.addNewInputLine();
                    this.scrollToBottom();
                }
            }

            // --- Guess the Number Game Logic ---
            startGameGuessTheNumber() {
                this.isGuessGameActive = true;
                this.guessGameSecretNumber = Math.floor(Math.random() * (this.guessGameMax - this.guessGameMin + 1)) + this.guessGameMin;
                this.guessGameAttemptsLeft = this.guessGameTotalAttempts;
                return `I've picked a number between ${this.guessGameMin} and ${this.guessGameMax}. You have ${this.guessGameAttemptsLeft} attempts.\nType your guess:`;
            }

            handleGuess(guessCmd) {
                if (!this.isGuessGameActive) return;

                const guess = parseInt(guessCmd);
                let message = "";

                if (isNaN(guess)) {
                    message = `"${guessCmd}" is not a valid number. Try again.\nYou have ${this.guessGameAttemptsLeft} attempts left.`;
                } else {
                    this.guessGameAttemptsLeft--;
                    if (guess === this.guessGameSecretNumber) {
                        message = `Correct! The number was ${this.guessGameSecretNumber}. You guessed it in ${this.guessGameTotalAttempts - this.guessGameAttemptsLeft} attempts.`;
                        this.isGuessGameActive = false; // Game over
                    } else if (this.guessGameAttemptsLeft === 0) {
                        message = `Sorry, you've run out of attempts! The number was ${this.guessGameSecretNumber}.`;
                        this.isGuessGameActive = false; // Game over
                    } else if (guess < this.guessGameSecretNumber) {
                        message = `Too low. You have ${this.guessGameAttemptsLeft} attempts left.\nType your guess:`;
                    } else { // guess > this.guessGameSecretNumber
                        message = `Too high. You have ${this.guessGameAttemptsLeft} attempts left.\nType your guess:`;
                    }
                }
                const output = this.createOutput(message);
                this.terminal.appendChild(output);

                if (!this.isGuessGameActive) { // Game just ended
                    // Optionally, add a message like "Type 'guess' to play again."
                }
            }
            // --- End Guess the Number Game Logic ---
        }

        function formatHelp(commands) {
            const categories = {
                personal: ['whoami', 'about', 'contact', 'projects',],
                system: ['help', 'clear', 'fetch', 'ssh'],
                fun: ['joke', 'catfact', 'guess'], // Added 'guess' here
                tools: ['tiers', 'define', 'calc', 'mcserver'],
                misc: ['credits', 'timesince'] // Moved timesince to misc for this example
            };

            let output = '';
            for (const category in categories) {
                output += `\n${category.toUpperCase()}:\n`;
                // Ensure all commands in the category exist in the main commands object
                const validCommandsInCategory = categories[category].filter(cmd => commands[cmd]);
                if (validCommandsInCategory.length === 0) continue;

                const maxCmdLen = Math.max(...validCommandsInCategory.map(cmd => cmd.length));
                validCommandsInCategory.forEach(cmd => {
                    output += `${cmd.padEnd(maxCmdLen + 2)}${commands[cmd].desc}\n`;
                });
            }
            return output;
        }

        function calculateElapsedTime(startDate) {
            const now = new Date();
            let timeDiff = now.getTime() - startDate.getTime();

            let milliseconds = Math.floor(timeDiff % 1000);
            timeDiff = Math.floor(timeDiff / 1000);
            let seconds = Math.floor(timeDiff % 60);
            timeDiff = Math.floor(timeDiff / 60);
            let minutes = Math.floor(timeDiff % 60);
            timeDiff = Math.floor(timeDiff / 60);
            let hours = Math.floor(timeDiff % 24);
            let days = Math.floor(timeDiff / 24);

            let years = Math.floor(days / 365);
            days %= 365;
            let months = Math.floor(days / 30);
            days %= 30;

            return `${years}y, ${months}m, ${days}d, ${hours}h, ${minutes}m, ${seconds}s, ${milliseconds}ms`;
        }

        function startTimesinceInterval() {
            if (window._timesinceInterval) return;
            window._timesinceInterval = setInterval(() => {
                const t1 = document.getElementById('timer1');
                const t2 = document.getElementById('timer2');
                if (t1) t1.textContent = calculateElapsedTime(new Date('2024-09-12T00:00:00Z'));
                if (t2) t2.textContent = calculateElapsedTime(new Date('2025-01-13T00:00:00Z'));
            }, 100);
        }

        const commands = {
            help: {
                desc: "Show this help message",
                execute: () => formatHelp(commands)
            },
            whoami: {
                desc: "Display current user",
                execute: () => "lynzl"
            },
            projects: {
                desc: "List projects",
                execute: () => [
                    "LokaMarketWatch (Unfinished) - Discord bot that tracks LokaMC markets https://github.com/Lyn1dev/lokamarketwatch",
                    "MCTierTagger               - In-game tiertagger fork to display tiers for mctiers.io",
                    "other random stuff like this website idk"
                ].join('\n')
            },
            contact: {
                desc: "Show contact information",
                execute: () => [
                    "discord: lyn1",
                    "github:  https://github.com/Lyn1dev"
                ].join('\n')
            },
            clear: {
                desc: "Clear the terminal",
                execute: function() { // `this` here is `commands.clear`
                    terminal.clearVisibleScreen(); // Use the global `terminal` instance
                    return ''; // Return empty or undefined so no extra output line is printed by default logic
                }
            },
            ssh: {
                desc: "Connect to a remote computer.",
                execute: (args) => {
                    if (args === 'madeline@spellbound') {
                        const question = `Are you sure you want to connect to ${args}? (yes/no)`;
                        const output = terminal.createOutput(question); 
                        terminal.terminal.appendChild(output); 

                        terminal.isWaitingForSshConfirmation = true;
                        terminal.sshTargetHost = args;

                        const inputLine = document.createElement('div');
                        inputLine.className = 'input-line confirmation-input-line'; 
                        inputLine.innerHTML = `
                            <span class="confirmation-prompt" style="color: var(--gray); margin-right: 0.5em;">></span>
                            <input type="text" class="command-input" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
                        `;
                        terminal.terminal.appendChild(inputLine);
                        terminal.input = inputLine.querySelector('.command-input');
                        terminal.input.focus();
                        terminal.setupEventListeners(); 
                        terminal.scrollToBottom();
                        return ''; // No default output, handled by confirmation logic
                    } else if (args) {
                        return `-bash: ssh: Could not resolve hostname ${args}: Name or service not known`;
                    }
                    else {
                        return "usage: ssh user@hostname. Try ssh madeline@spellbound";
                    }
                }
            },
            fetch: {
                desc: "Display system information",
                execute: () => {
                    const logoLines = [
                        "...=*#*+...*.*.",
                        ".*#%%%%%#**#**%*:",
                        "      **##@%##*+",
                        "      +##**+*#####**#",
                        "        #*++**********##",
                        "      *%*+******##*##**#@         *. ",
                        "      *#****@##**##+++++++++++****+** ",
                        "      .%@#**#++++*******@@%***%=       ",
                        "  %%@@@@#++++**+****%%@.              ",
                        " %%@@#+++=+*%%@.                      ",
                        "#+%=#@@+=                            "
                    ];
                    const infoLines = [
                        "{blue}lynzl{reset}{gray}@{blue}spellbound{reset}",
                        "{gray}---------------------------{reset}",
                        "{blue}OS:        {reset}{white}spellboundOS v0.1{reset}",
                        "{blue}Kernel:    {reset}{white}6.1.0-31-amd64{reset}",
                        "{blue}Uptime:    {reset}{white}4 years, 230 days, 12 hours, 6 min{reset}",
                        "{blue}Packages:  {reset}{white}54 (dpkg){reset}",
                        "{blue}Shell:     {reset}{white}bash 5.2.15{reset}",
                        "{blue}Terminal:  {reset}{white}/dev/pts/0{reset}",
                        "{blue}CPU:       {reset}{white}AMD Ryzen 12 9900 (194){reset}",
                        "{blue}GPU:       {reset}{white}NVIDIA RTX 6090{reset}",
                        "{blue}Memory:    {reset}{white}19995MiB / 63745MiB{reset}"
                    ];
                    const logoWidth = Math.max(...logoLines.map(l => l.length));
                    // const infoWidth = Math.max(...infoLines.map(l => l.replace(/\{[^}]+\}/g, '').length));
                    const lines = [];
                    const totalLines = Math.max(logoLines.length, infoLines.length);
                    for (let i = 0; i < totalLines; i++) {
                        const logo = logoLines[i] ? logoLines[i].padEnd(logoWidth, ' ') : ' '.repeat(logoWidth);
                        const info = infoLines[i] ? infoLines[i] : '';
                        lines.push(logo + '   ' + info);
                    }
                    const colorBar =
                        ' '.repeat(logoWidth + 3) +
                        '{gray}██{reset}' +
                        '{red}██{reset}' +
                        '{yellow}██{reset}' +
                        '{green}██{reset}' +
                        '{mint}██{reset}' +
                        '{blue}██{reset}' +
                        '{lavender}██{reset}' +
                        '{white}██{reset}';
                    lines.push('');
                    lines.push(colorBar);
                    let out = lines.join('\n');
                    const colorMap = {
                        lavender: 'var(--lavender)', lilac: 'var(--lilac)', mint: 'var(--mint)',
                        pink: 'var(--pink)', blue: 'var(--blue)', yellow: 'var(--yellow)',
                        white: 'var(--white)', gray: 'var(--gray)', red: '#f38ba8',
                        green: '#a6e3a1', reset: 'var(--white)' // reset to default text color
                    };
                    // Simpler span replacement:
                    out = out.replace(/\{(\w+)\}/g, (match, colorName) => {
                        const colorValue = colorMap[colorName.toLowerCase()];
                        if (colorValue === colorMap.reset) { // If it's {reset}
                            return '</span>';
                        } else if (colorValue) {
                            return `<span style="color:${colorValue}">`;
                        }
                        return match; // Should not happen if all placeholders are in colorMap
                    });
                    // Ensure any unclosed spans are closed if the line ends before a {reset}
                    // This is a basic fix; more robust parsing might be needed for complex cases.
                    const openSpans = (out.match(/<span/g) || []).length;
                    const closeSpans = (out.match(/<\/span/g) || []).length;
                    if (openSpans > closeSpans) {
                        out += '</span>'.repeat(openSpans - closeSpans);
                    }
                    return `<pre style='margin:0;background:none;border:none;font-family:inherit;font-size:inherit;line-height:1.1;'>${out}</pre>`;
                }
            },
            about: {
                desc: "About me",
                execute: () => [
                    "I'm lynzl, i like cats idk",
                    "I'm pretty good at Java, JavaScript, Python and other stuff.",
                    "I play video games sometimes.",
                    "I do take commissions if you wanna hire me to code something lol"
                ].join('\n')
            },
            credits: {
                desc: "Show credits for this project",
                execute: () => [
                    "The idea for this website came solely from 'madeline.sh'",
                    "You should check that site out, it is so much cooler than this one!",
                    "madeline gave me this subdomain. run `ssh madeline@spellbound`."
                ].join('\n')
            },
            timesince: {
                desc: "Live timers for two very important dates",
                execute: () => {
                    setTimeout(() => {
                        const outputs = document.querySelectorAll('.output');
                        let last = null;
                        outputs.forEach(o => {
                            if (o.textContent.includes('💊') && o.textContent.includes('❤️')) last = o;
                        });
                        if (last && !last.querySelector('#timer1')) { // Check if spans already exist
                            last.innerHTML = last.innerHTML.replace(
                                /💊 ([^\n]*)/,
                                '💊 <span id="timer1">$1</span>'
                            ).replace(
                                /❤️ ([^\n]*)/,
                                '❤️ <span id="timer2">$1</span>'
                            );
                        }
                        startTimesinceInterval();
                    }, 0);
                    return [ // Initial output
                        '💊 Loading...',
                        '❤️ Loading...'
                    ].join('\n');
                }
            },
            joke: {
                desc: "Display a random joke. Try `joke pun`! (Categories: programming, misc, dark, pun, spooky, christmas)",
                execute: (category) => {
                    return getJoke(category).then(joke => joke);
                }
            },
            catfact: {
                desc: "Display a random cat fact",
                execute: () => {
                    return getCatFact().then(fact => fact);
                }
            },
            tiers: {
                desc: "Lookup user tiers on mctiers.io",
                execute: (username) => {
                    if (!username) {
                        return "usage: tiers <username>";
                    }
                    return getUserTiers(username).then(tiers => tiers);
                }
            },
            define: {
                desc: "Define a word",
                execute: (word) => {
                    if (!word) {
                        return "usage: define <word>";
                    }
                    return getDefinition(word).then(definition => definition);
                }
            },
            calc: {
                desc: "Evaluate a mathematical expression",
                execute: (expression) => {
                    if (!expression) {
                        return "usage: calc <yourmath here>";
                    }
                    return evaluateExpression(expression);
                }
            },
            mcserver: {
                desc: "Lookup Minecraft server status",
                execute: (address) => {
                    if (!address) {
                        return "usage: mcserver <address>";
                    }
                    return getMinecraftServerStatus(address).then(status => status);
                }
            },
            // --- NEW GAME COMMAND ---
            guess: {
                desc: "Play a 'Guess the Number' game.",
                execute: () => { // `this` here is `commands.guess`
                    return terminal.startGameGuessTheNumber(); // Use the global `terminal` instance
                }
            }
        };

        const terminal = new Terminal(); // Initialize terminal instance globally

        function getJoke(category) {
            let url = 'https://v2.jokeapi.dev/joke/Any?blacklistFlags=nsfw,religious,political,racist,sexist,explicit'; // Added blacklist
            if (category) {
                const validCategories = ["programming", "misc", "dark", "pun", "spooky", "christmas"];
                if (validCategories.includes(category.toLowerCase())) {
                    url = `https://v2.jokeapi.dev/joke/${category}?blacklistFlags=nsfw,religious,political,racist,sexist,explicit`;
                } else {
                    return Promise.resolve(`Invalid category. Try: ${validCategories.join(', ')} or no category for Any.`);
                }
            }

            return fetch(url)
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        return "Failed to fetch joke. API error or invalid category.";
                    }
                    if (data.joke) {
                        return data.joke;
                    } else if (data.setup && data.delivery) {
                        return `${data.setup}\n${data.delivery}`;
                    } else {
                        return "No joke found with the current filters/category.";
                    }
                })
                .catch(error => {
                    console.error("Error fetching joke:", error);
                    return "Failed to fetch joke due to a network or parsing error.";
                });
        }

        function getCatFact() {
            const url = 'https://meowfacts.herokuapp.com';
            return fetch(url)
                .then(response => response.json())
                .then(data => {
                    if (data && data.data && Array.isArray(data.data) && data.data.length > 0) {
                        return data.data[0]; 
                    } else {
                        console.warn("Unexpected API response structure from meowfacts:", data);
                        return "Failed to fetch cat fact: Unexpected API response format.";
                    }
                })
                .catch(error => {
                    console.error("Error fetching cat fact:", error);
                    return "Failed to fetch cat fact.";
                });
        }

        function getUserTiers(username) {
            const url = `https://mctiers.io/api/search_profile/${username}`;
            return fetch(url)
                .then(response => {
                    if (!response.ok) {
                         // MCTiers API returns 200 with an error message in JSON for "user not found"
                        if (response.status === 404) throw new Error(`User "${username}" not found on MCTiers.`);
                        // For other HTTP errors
                        // throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data && data.rankings) { // Successful response with data
                        let output = `Tiers for ${username}:\n`;
                        if (Object.keys(data.rankings).length === 0) {
                            return `No tier data found for ${username} on mctiers.io.`;
                        }
                        for (const gamemode in data.rankings) {
                            const tierData = data.rankings[gamemode];
                            const retired = tierData.retired ? 'R' : '';
                            const pos = tierData.pos === 1 ? 'L' : (tierData.pos === 2 ? 'M' : 'H'); // L, M, H
                            const tier = tierData.tier;
                            output += `${gamemode.charAt(0).toUpperCase() + gamemode.slice(1)}: ${retired}${pos}T${tier}\n`;
                        }
                        return output;
                    } else if (data && data.message) { // API returned an error message (e.g., user not found)
                        return `MCTiers: ${data.message}`;
                    } else {
                        return `No tier data found for ${username} or unexpected API response.`;
                    }
                })
                .catch(error => {
                    console.error("Error fetching user tiers:", error);
                    return `Failed to fetch user tiers for "${username}": ${error.message}`;
                });
        }

        function getDefinition(word) {
            const url = `https://api.dictionaryapi.dev/api/v2/entries/en/${word}`;
            return fetch(url)
                .then(response => {
                    if (!response.ok) {
                        if (response.status === 404) {
                            return { error: `Word "${word}" not found.` }; // Special object for 404
                        }
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.error) { // For 404 error passed as object
                        return data.error;
                    }
                    if (!data || data.length === 0 || (data.title && data.title === "No Definitions Found")) {
                        return `No definition found for "${word}".`;
                    }
                    // Process and format the definition
                    let formattedOutput = `Definitions for "${word}":\n`;
                    data.forEach(entry => {
                        formattedOutput += `\nPhonetic: ${entry.phonetic || 'N/A'}\n`;
                        entry.meanings.forEach(meaning => {
                            formattedOutput += `\n Part of speech: ${meaning.partOfSpeech}\n`;
                            meaning.definitions.forEach((def, index) => {
                                formattedOutput += `  ${index + 1}. ${def.definition}\n`;
                                if (def.example) {
                                    formattedOutput += `     Example: ${def.example}\n`;
                                }
                            });
                        });
                    });
                    return formattedOutput;
                })
                .catch(error => {
                    console.error("Error fetching definition:", error);
                    return `Failed to fetch definition for "${word}": ${error.message}`;
                });
        }

        function evaluateExpression(expression) {
            try {
                // A more robust and safer way would be to use a math expression parser library
                // For simplicity, using Function constructor, but BEWARE: IT'S LIKE EVAL, UNSAFE WITH ARBITRARY USER INPUT
                // This implementation assumes simple math and does not allow access to global scope or functions beyond Math.
                const sanitizedExpression = expression.replace(/[^-()\d/*+%.e\s]/g, ''); // Basic sanitization
                if (sanitizedExpression !== expression) {
                    //return "Error: Invalid characters in expression."; // too restrictive
                }
                const result = new Function('return ' + sanitizedExpression)();
                if (typeof result !== 'number' || isNaN(result)) {
                    return "Error: Invalid expression or result is not a number.";
                }
                return result.toString();
            } catch (e) {
                return `Error: ${e.message}`;
            }
        }

        function getMinecraftServerStatus(address) {
            const url = `https://api.mcsrvstat.us/2/${address}`;
            return fetch(url)
                .then(response => response.json())
                .then(data => {
                    if (data.online) {
                        let output = `Server: ${address} is ONLINE\n`;
                        output += `MOTD: ${Array.isArray(data.motd.clean) ? data.motd.clean.join('\\n      ') : data.motd.clean}\n`;
                        output += `Players: ${data.players.online} / ${data.players.max}\n`;
                        output += `Version: ${data.version}\n`;
                        if (data.software) output += `Software: ${data.software}\n`;
                        if (data.plugins && data.plugins.names && data.plugins.names.length > 0) {
                            output += `Plugins (${data.plugins.names.length}): ${data.plugins.names.join(', ')}\n`;
                        }
                        return output;
                    } else {
                        return `Server: ${address} is OFFLINE or could not be reached.`;
                    }
                })
                .catch(error => {
                    console.error("Error fetching Minecraft server status:", error);
                    return `Failed to fetch status for ${address}: ${error.message}`;
                });
        }

    </script>
</body>
</html>